<div id="container" class="stratigraphic-test-page">
  <main class="control-fullscreen">
    <!-- État initial - avant la recherche -->
    <section *ngIf="!hasSearched && !isSearching" class="empty-state">
      <ion-icon name="document-text-outline" class="empty-icon"></ion-icon>
      <h2>Contrôle stratigraphique</h2>
      <p>Vérifiez la cohérence des relations stratigraphiques de votre projet</p>

      <!-- Sélecteur de type de contrôle -->
      <div class="control-type-selector">
        <ion-segment [(ngModel)]="selectedParadoxType" mode="ios">
          <ion-segment-button 
            *ngFor="let type of paradoxTypes"
            [value]="type.id"
            [title]="type.description">
            <ion-label>{{ type.name }}</ion-label>
          </ion-segment-button>
        </ion-segment>
      </div>

      <ion-button 
        (click)="findParadoxes()" 
        color="primary"
        class="ion-margin-top"
        [disabled]="isSearching">
        <ion-icon name="checkmark-done-outline" slot="start"></ion-icon>
        Lancer le contrôle
      </ion-button>
    </section>

    <!-- Overlay de chargement -->
    <div *ngIf="isSearching" class="loading-overlay">
      <ion-spinner name="crescent"></ion-spinner>
      <p>Analyse en cours...</p>
    </div>

    <!-- Résultats -->
    <section *ngIf="hasSearched && !isSearching" class="results-section">
      <!-- Header des résultats -->
      <div class="results-header">
        <div class="results-title">
          <ion-icon name="document-text-outline"></ion-icon>
          <h2>Résultats du contrôle</h2>
        </div>
        <!-- Indicateur du filtre actif -->
        <ion-chip *ngIf="selectedParadoxType" color="primary" class="filter-chip">
          <ion-icon name="funnel-outline"></ion-icon>
          <ion-label>{{ getParadoxTypeLabel(selectedParadoxType) }}</ion-label>
        </ion-chip>
      </div>

      <!-- Message de succès si aucun paradoxe -->
      <div *ngIf="paradoxResults.length === 0" class="success-state">
        <ion-icon name="checkmark-circle-outline" class="success-icon"></ion-icon>
        <h3>Tout semble cohérent dans les relations stratigraphiques, Bravo !</h3>
      </div>

      <!-- Liste des paradoxes groupés -->
      <div *ngIf="paradoxResults.length > 0" class="paradoxes-container">
        <div class="paradoxes-summary">
          <ion-chip color="danger">
            <ion-icon name="warning-outline"></ion-icon>
            <ion-label>{{ paradoxResults.length }} problème(s) détecté(s)</ion-label>
          </ion-chip>
        </div>

        <div *ngFor="let entry of groupedParadoxes | keyvalue:paradoxKeyValueComparator" class="paradox-group">
          <ng-container *ngIf="entry.value.length > 0">
            <div class="group-header" (click)="toggleGroupExpand(entry.key)">
              <ion-item lines="none" detail="false" button>
                <ion-icon [name]="expandedGroups[entry.key] ? 'chevron-down' : 'chevron-forward'" slot="start"></ion-icon>
                <ion-label>
                  <h2>{{ formatParadoxType(entry.key) }}</h2>
                  <p>{{ entry.value.length }} occurrence(s)</p>
                </ion-label>
                <ion-badge slot="end" [color]="getParadoxBadgeColor(entry.key)">
                  {{ entry.value.length }}
                </ion-badge>
              </ion-item>
            </div>

            <div class="group-content" [hidden]="!expandedGroups[entry.key]">
              <div *ngFor="let paradox of entry.value; let i = index" class="paradox-item">

                <!-- Affichage pour les cycles (DIRECT et INDIRECT) -->
                <ng-container *ngIf="isCycleParadox(paradox)">
                  <ion-item button detail (click)="toggleCycleExpand(entry.key, i, $event)" class="cycle-header">
                    <ion-icon slot="start" [name]="isCycleExpanded(entry.key, i) ? 'chevron-down' : 'chevron-forward'"></ion-icon>
                    <ion-label class="ion-text-wrap">
                      <div class="cycle-description">
                        <!-- Badge pour indiquer si c'est un cycle indirect -->
                        <div class="cycle-type-indicator">
                          <span class="relation-count">{{ getInvolvedRelationsCount(paradox) }} relations impliquées</span>
                          <ion-badge *ngIf="isIndirectCycle(paradox)" color="tertiary" class="indirect-badge">
                            <ion-icon name="git-network-outline"></ion-icon>
                            Indirect
                          </ion-badge>
                        </div>
                        
                        <!-- Affichage des entités du cycle -->
                        <div class="cycle-entities">
                          
                          <!-- CAS 1: Cycle avec CycleNodeInfos (peut contenir des groupes) -->
                          <ng-container *ngIf="hasCycleNodeInfos(paradox)">
                            <ng-container *ngFor="let nodeInfo of getCycleNodeInfos(paradox); let idx = index">
                              
                              <!-- Nœud simple (une seule entité) -->
                              <ng-container *ngIf="!isGroupNode(nodeInfo)">
                                <ng-container *ngIf="getEntityTable(nodeInfo.memberUUIDs[0]) as table">
                                  <app-castor-tag-display
                                    [description]="{table: table, uuid: nodeInfo.memberUUIDs[0]}"
                                    [infoBulle]="true">
                                  </app-castor-tag-display>
                                </ng-container>
                              </ng-container>
                              
                              <!-- Nœud groupe (plusieurs entités contemporaines) -->
                              <ng-container *ngIf="isGroupNode(nodeInfo)">
                                <div class="contemporaneity-group" 
                                    [title]="'Groupe de contemporanéité : ' + getGroupDescription(nodeInfo)">
                                  <span class="group-bracket">{{'{'}}</span>
                                  <ng-container *ngFor="let memberUUID of nodeInfo.memberUUIDs; let memberIdx = index">
                                    <ng-container *ngIf="getMemberTable(memberUUID) as memberTable">
                                      <app-castor-tag-display
                                        [description]="{table: memberTable, uuid: memberUUID}"
                                        [infoBulle]="true">
                                      </app-castor-tag-display>
                                    </ng-container>
                                    <span *ngIf="memberIdx < nodeInfo.memberUUIDs.length - 1" class="group-separator">,</span>
                                  </ng-container>
                                  <span class="group-bracket">{{'}'}}</span>
                                </div>
                              </ng-container>
                              
                              <span class="arrow">→</span>
                            </ng-container>
                            
                            <!-- Fermer le cycle : répéter le premier élément -->
                            <ng-container *ngIf="getCycleNodeInfos(paradox).length > 0">
                              <ng-container *ngIf="!isGroupNode(getCycleNodeInfos(paradox)[0])">
                                <ng-container *ngIf="getEntityTable(getCycleNodeInfos(paradox)[0].memberUUIDs[0]) as firstTable">
                                  <app-castor-tag-display
                                    [description]="{table: firstTable, uuid: getCycleNodeInfos(paradox)[0].memberUUIDs[0]}"
                                    [infoBulle]="true">
                                  </app-castor-tag-display>
                                </ng-container>
                              </ng-container>
                              <ng-container *ngIf="isGroupNode(getCycleNodeInfos(paradox)[0])">
                                <div class="contemporaneity-group">
                                  <span class="group-bracket">{{'{'}}</span>
                                  <ng-container *ngFor="let memberUUID of getCycleNodeInfos(paradox)[0].memberUUIDs; let memberIdx = index">
                                    <ng-container *ngIf="getMemberTable(memberUUID) as memberTable">
                                      <app-castor-tag-display
                                        [description]="{table: memberTable, uuid: memberUUID}"
                                        [infoBulle]="true">
                                      </app-castor-tag-display>
                                    </ng-container>
                                    <span *ngIf="memberIdx < getCycleNodeInfos(paradox)[0].memberUUIDs.length - 1" class="group-separator">,</span>
                                  </ng-container>
                                  <span class="group-bracket">{{'}'}}</span>
                                </div>
                              </ng-container>
                            </ng-container>
                          </ng-container>
                          
                          <!-- CAS 2: Fallback - Cycle sans CycleNodeInfos (ancien format, cycles directs) -->
                          <ng-container *ngIf="!hasCycleNodeInfos(paradox)">
                            <ng-container *ngFor="let nodeUUID of paradox.cycleNodesUUIDs; let idx = index">
                              <ng-container *ngIf="getEntityTable(nodeUUID) as table">
                                <app-castor-tag-display
                                  [description]="{table: table, uuid: nodeUUID}"
                                  [infoBulle]="true">
                                </app-castor-tag-display>
                              </ng-container>
                              <span class="arrow">→</span>
                            </ng-container>
                            <ng-container *ngIf="paradox.cycleNodesUUIDs?.length > 0 && getEntityTable(paradox.cycleNodesUUIDs[0]) as firstTable">
                              <app-castor-tag-display
                                [description]="{table: firstTable, uuid: paradox.cycleNodesUUIDs[0]}"
                                [infoBulle]="true">
                              </app-castor-tag-display>
                            </ng-container>
                          </ng-container>
                          
                        </div>
                      </div>
                    </ion-label>
                  </ion-item>

                  <!-- Détails du cycle (tableau des relations) -->
                  <div *ngIf="isCycleExpanded(entry.key, i)" class="cycle-details">
                    <!-- Message explicatif pour les cycles indirects -->
                    <div *ngIf="isIndirectCycle(paradox)" class="indirect-cycle-info">
                      <ion-icon name="information-circle-outline"></ion-icon>
                      <p>
                        Ce cycle est <strong>indirect</strong> : il n'existe qu'à travers les groupes de contemporanéité.
                        Les entités entre accolades <code>{{'{'}}...{{'}'}}</code> sont contemporaines entre elles.
                        <span *ngIf="getGroupCountInCycle(paradox) > 0">
                          ({{ getGroupCountInCycle(paradox) }} groupe(s) de contemporanéité impliqué(s))
                        </span>
                      </p>
                    </div>
                    
                    <table class="table strati-relation-table">
                      <tbody>
                        <tr *ngFor="let relation of paradox.allRelations" [attr.data-relation-id]="relation.stratigraphie_uuid">
                          <td class="relation-content">
                            <!-- Relation de contemporanéité -->
                            <ng-container *ngIf="relation.is_contemporain">
                              <app-castor-tag-display *ngIf="relation.us_anterieur"
                                [description]="{table: ApiDbTable.us, uuid: relation.us_anterieur}"
                                [infoBulle]="true"></app-castor-tag-display>
                              <app-castor-tag-display *ngIf="relation.fait_anterieur"
                                [description]="{table: ApiDbTable.fait, uuid: relation.fait_anterieur}"
                                [infoBulle]="true"></app-castor-tag-display>
                              
                              <span class="relation-type contemporain-type">
                                <app-castor-type-display
                                  [type]="relation.strati_type_uuid"
                                  [display_prefix]="false"></app-castor-type-display>
                              </span>

                              <app-castor-tag-display *ngIf="relation.us_posterieur"
                                [description]="{table: ApiDbTable.us, uuid: relation.us_posterieur}"
                                [infoBulle]="true"></app-castor-tag-display>
                              <app-castor-tag-display *ngIf="relation.fait_posterieur"
                                [description]="{table: ApiDbTable.fait, uuid: relation.fait_posterieur}"
                                [infoBulle]="true"></app-castor-tag-display>
                            </ng-container>
                            
                            <!-- Relation temporelle (sous/sur) -->
                            <ng-container *ngIf="!relation.is_contemporain">
                              <app-castor-tag-display *ngIf="relation.us_posterieur"
                                [description]="{table: ApiDbTable.us, uuid: relation.us_posterieur}"
                                [infoBulle]="true"></app-castor-tag-display>
                              <app-castor-tag-display *ngIf="relation.fait_posterieur"
                                [description]="{table: ApiDbTable.fait, uuid: relation.fait_posterieur}"
                                [infoBulle]="true"></app-castor-tag-display>
                              
                              <span class="relation-type contemporain-type">
                                <app-castor-type-display
                                  [type]="relation.strati_type_uuid"
                                  [display_prefix]="false"></app-castor-type-display> 
                              </span>

                              <app-castor-tag-display *ngIf="relation.us_anterieur"
                                [description]="{table: ApiDbTable.us, uuid: relation.us_anterieur}"
                                [infoBulle]="true"></app-castor-tag-display>
                              <app-castor-tag-display *ngIf="relation.fait_anterieur"
                                [description]="{table: ApiDbTable.fait, uuid: relation.fait_anterieur}"
                                [infoBulle]="true"></app-castor-tag-display>
                            </ng-container>
                          </td>
                          <td class="text-end align-middle action-column">
                            <ion-icon name="eye-outline" class="preview-icon" title="Voir l'impact"
                              (click)="$event.stopPropagation(); simulateRelationRemoval(relation, $event)"></ion-icon>
                            <ion-icon *ngIf="canDeleteRelation(relation)" name="trash-outline" class="delete-icon" title="Supprimer"
                              (click)="$event.stopPropagation(); deleteRelation(relation, $event)"></ion-icon>
                          </td>
                        </tr>
                      </tbody>
                    </table>
                  </div>
                </ng-container>

                <!-- Affichage pour les autres types (temporal, consistency, containment) -->
                <ng-container *ngIf="!isCycleParadox(paradox)">
                  
                  <!-- ============================================================ -->
                  <!-- CAS 1 : Paradoxe TEMPORAL INDIRECT (via contemporanéité) -->
                  <!-- ============================================================ -->
                  <ng-container *ngIf="paradox.type === 'temporal' && isIndirectTemporalParadox(paradox)">
                    <ion-item button detail (click)="toggleCycleExpand(entry.key, i, $event)" class="cycle-header indirect-temporal-header">
                      <ion-icon slot="start" [name]="isCycleExpanded(entry.key, i) ? 'chevron-down' : 'chevron-forward'"></ion-icon>
                      <ion-label class="ion-text-wrap">
                        <div class="paradox-header-content">
                          <!-- Badge Indirect -->
                          <div class="paradox-type-indicator">
                            <ion-badge color="tertiary" class="indirect-badge">
                              <ion-icon name="git-network-outline"></ion-icon>
                              Indirect
                            </ion-badge>
                          </div>
                          
                          <!-- Message court -->
                          <p class="paradox-summary" [innerHTML]="paradox.shortMessage || getShortMessage(paradox)"></p>
                          
                          <!-- Affichage du groupe de contemporanéité -->
                          <div class="contemporaneity-group-display" *ngIf="hasTemporalParadoxInfo(paradox)">
                            <span class="group-label">Groupe de contemporanéité :</span>
                            <div class="contemporaneity-group inline-group">
                              <span class="group-bracket">{{ '{' }}</span>
                              <ng-container *ngFor="let memberUUID of getTemporalGroupMemberUUIDs(paradox); let memberIdx = index">
                                <ng-container *ngIf="getEntityTable(memberUUID) as memberTable">
                                  <app-castor-tag-display
                                    [description]="{table: memberTable, uuid: memberUUID}"
                                    [infoBulle]="true">
                                  </app-castor-tag-display>
                                </ng-container>
                                <span *ngIf="memberIdx < getTemporalGroupMemberUUIDs(paradox).length - 1" class="group-separator">,</span>
                              </ng-container>
                              <span class="group-bracket">{{ '}' }}</span>
                            </div>
                          </div>
                          
                          <!-- Compteur de relations -->
                          <p class="relation-count">{{ formatTemporalRelationsCount(paradox) }}</p>
                        </div>
                      </ion-label>
                    </ion-item>

                    <!-- Détails du paradoxe temporal indirect -->
                    <div *ngIf="isCycleExpanded(entry.key, i)" class="standard-details indirect-temporal-details">
                      <!-- Message d'information -->
                      <div class="indirect-cycle-info">
                        <ion-icon name="information-circle-outline"></ion-icon>
                        <p>
                          Ce paradoxe est <strong>indirect</strong> : les deux entités sont contemporaines via une chaîne de relations de contemporanéité.
                          Une relation temporelle ne peut pas exister entre des entités contemporaines.
                        </p>
                      </div>
                      
                      <!-- Section : Relations de contemporanéité -->
                      <div class="relations-section" *ngIf="getContemporaneityRelations(paradox).length > 0">
                        <h4>
                          Relations de contemporanéité ({{ getContemporaneityRelations(paradox).length }})
                        </h4>
                        <table class="table strati-relation-table">
                          <tbody>
                            <tr *ngFor="let relation of getContemporaneityRelations(paradox)" 
                                [attr.data-relation-id]="relation.stratigraphie_uuid"
                                class="contemporaneity-relation-row">
                              <td class="relation-content">
                                <app-castor-tag-display *ngIf="relation.us_anterieur"
                                  [description]="{table: ApiDbTable.us, uuid: relation.us_anterieur}"
                                  [infoBulle]="true"></app-castor-tag-display>
                                <app-castor-tag-display *ngIf="relation.fait_anterieur"
                                  [description]="{table: ApiDbTable.fait, uuid: relation.fait_anterieur}"
                                  [infoBulle]="true"></app-castor-tag-display>
                                
                                <span class="relation-type contemporain-type">
                                  <app-castor-type-display
                                    [type]="relation.strati_type_uuid"
                                    [display_prefix]="false"></app-castor-type-display>
                                </span>

                                <app-castor-tag-display *ngIf="relation.us_posterieur"
                                  [description]="{table: ApiDbTable.us, uuid: relation.us_posterieur}"
                                  [infoBulle]="true"></app-castor-tag-display>
                                <app-castor-tag-display *ngIf="relation.fait_posterieur"
                                  [description]="{table: ApiDbTable.fait, uuid: relation.fait_posterieur}"
                                  [infoBulle]="true"></app-castor-tag-display>
                              </td>
                              <td class="text-end align-middle action-column">
                                <ion-icon name="eye-outline" class="preview-icon" title="Voir l'impact"
                                  (click)="$event.stopPropagation(); simulateRelationRemoval(relation, $event)"></ion-icon>
                                <ion-icon *ngIf="canDeleteRelation(relation)" name="trash-outline" class="delete-icon" title="Supprimer"
                                  (click)="$event.stopPropagation(); deleteRelation(relation, $event)"></ion-icon>
                              </td>
                            </tr>
                          </tbody>
                        </table>
                      </div>
                      
                      <!-- Section : Relation temporelle en conflit -->
                      <div class="relations-section conflicting-relation-section" *ngIf="getConflictingTemporalRelation(paradox) as conflictRelation">
                        <h4>
                          <ion-icon name="warning-outline" color="danger"></ion-icon>
                          Relation temporelle en conflit
                        </h4>
                        <table class="table strati-relation-table">
                          <tbody>
                            <tr [attr.data-relation-id]="conflictRelation.stratigraphie_uuid" class="conflicting-relation-row">
                              <td class="relation-content">
                                <app-castor-tag-display *ngIf="conflictRelation.us_posterieur"
                                  [description]="{table: ApiDbTable.us, uuid: conflictRelation.us_posterieur}"
                                  [infoBulle]="true"></app-castor-tag-display>
                                <app-castor-tag-display *ngIf="conflictRelation.fait_posterieur"
                                  [description]="{table: ApiDbTable.fait, uuid: conflictRelation.fait_posterieur}"
                                  [infoBulle]="true"></app-castor-tag-display>

                                <span class="relation-type temporal-conflict-type">
                                  <strong>
                                    <app-castor-type-display
                                      [type]="conflictRelation.strati_type_uuid"
                                      [display_prefix]="false"></app-castor-type-display>
                                  </strong>
                                </span>
                                
                                <app-castor-tag-display *ngIf="conflictRelation.us_anterieur"
                                  [description]="{table: ApiDbTable.us, uuid: conflictRelation.us_anterieur}"
                                  [infoBulle]="true"></app-castor-tag-display>
                                <app-castor-tag-display *ngIf="conflictRelation.fait_anterieur"
                                  [description]="{table: ApiDbTable.fait, uuid: conflictRelation.fait_anterieur}"
                                  [infoBulle]="true"></app-castor-tag-display>
                              </td>
                              <td class="text-end align-middle action-column">
                                <ion-icon name="eye-outline" class="preview-icon" title="Voir l'impact"
                                  (click)="$event.stopPropagation(); simulateRelationRemoval(conflictRelation, $event)"></ion-icon>
                                <ion-icon *ngIf="canDeleteRelation(conflictRelation)" name="trash-outline" class="delete-icon" title="Supprimer"
                                  (click)="$event.stopPropagation(); deleteRelation(conflictRelation, $event)"></ion-icon>
                              </td>
                            </tr>
                          </tbody>
                        </table>
                      </div>
                    </div>
                  </ng-container>

                  <!-- ============================================================ -->
                  <!-- CAS 2 : Paradoxes SIMPLES (temporal direct, consistency, containment) -->
                  <!-- ============================================================ -->
                  <ng-container *ngIf="!(paradox.type === 'temporal' && isIndirectTemporalParadox(paradox))">
                    <ion-item button detail (click)="toggleCycleExpand(entry.key, i, $event)" class="cycle-header">
                      <ion-icon slot="start" [name]="isCycleExpanded(entry.key, i) ? 'chevron-down' : 'chevron-forward'"></ion-icon>
                      <ion-label class="ion-text-wrap">
                        <p class="paradox-summary" [innerHTML]="paradox.message || getShortMessage(paradox)"></p>
                        <p class="relation-count">{{ getInvolvedRelationsCount(paradox) }} relation(s) impliquée(s)</p>
                      </ion-label>
                    </ion-item>

                    <div *ngIf="isCycleExpanded(entry.key, i)" class="standard-details">
                      <table class="table strati-relation-table">
                        <tbody>
                          <tr *ngFor="let relation of paradox.relations" [attr.data-relation-id]="relation.stratigraphie_uuid">
                            <td class="relation-content">
                              <ng-container *ngIf="!relation.is_contemporain">
                                <app-castor-tag-display *ngIf="relation.us_posterieur"
                                  [description]="{table: ApiDbTable.us, uuid: relation.us_posterieur}"
                                  [infoBulle]="true"></app-castor-tag-display>
                                <app-castor-tag-display *ngIf="relation.fait_posterieur"
                                  [description]="{table: ApiDbTable.fait, uuid: relation.fait_posterieur}"
                                  [infoBulle]="true"></app-castor-tag-display>
                                
                                <span class="relation-type contemporain-type">
                                  <app-castor-type-display
                                    [type]="relation.strati_type_uuid"
                                    [display_prefix]="false"></app-castor-type-display>
                                </span>
                                  
                                <app-castor-tag-display *ngIf="relation.us_anterieur"
                                  [description]="{table: ApiDbTable.us, uuid: relation.us_anterieur}"
                                  [infoBulle]="true"></app-castor-tag-display>
                                <app-castor-tag-display *ngIf="relation.fait_anterieur"
                                  [description]="{table: ApiDbTable.fait, uuid: relation.fait_anterieur}"
                                  [infoBulle]="true"></app-castor-tag-display>
                              </ng-container>
                              <ng-container *ngIf="relation.is_contemporain">
                                <app-castor-tag-display *ngIf="relation.us_posterieur"
                                  [description]="{table: ApiDbTable.us, uuid: relation.us_posterieur}"
                                  [infoBulle]="true"></app-castor-tag-display>
                                <app-castor-tag-display *ngIf="relation.fait_posterieur"
                                  [description]="{table: ApiDbTable.fait, uuid: relation.fait_posterieur}"
                                  [infoBulle]="true"></app-castor-tag-display>

                                <span class="relation-type contemporain-type">
                                  <app-castor-type-display
                                    [type]="relation.strati_type_uuid"
                                    [display_prefix]="false"></app-castor-type-display>
                                </span>

                                <app-castor-tag-display *ngIf="relation.us_anterieur"
                                  [description]="{table: ApiDbTable.us, uuid: relation.us_anterieur}"
                                  [infoBulle]="true"></app-castor-tag-display>
                                <app-castor-tag-display *ngIf="relation.fait_anterieur"
                                  [description]="{table: ApiDbTable.fait, uuid: relation.fait_anterieur}"
                                  [infoBulle]="true"></app-castor-tag-display>
                              </ng-container>
                            </td>
                            <td class="text-end align-middle action-column">
                              <ion-icon name="eye-outline" class="preview-icon" title="Voir l'impact"
                                (click)="$event.stopPropagation(); simulateRelationRemoval(relation, $event)"></ion-icon>
                              <ion-icon *ngIf="canDeleteRelation(relation)" name="trash-outline" class="delete-icon" title="Supprimer"
                                (click)="$event.stopPropagation(); deleteRelation(relation, $event)"></ion-icon>
                            </td>
                          </tr>
                        </tbody>
                      </table>
                    </div>
                  </ng-container>
                  
                </ng-container>
              </div>
            </div>
          </ng-container>
        </div>
      </div>
    </section>
  </main>

  <!-- ===== FLOATING ACTION BUTTONS (visibles uniquement après la recherche) ===== -->
  
  <!-- Bouton Relancer le contrôle -->
  <app-floating-action-button
    *ngIf="hasSearched && !isSearching"
    icon="reload-outline"
    [position]="'top-right'"
    [offsetTop]="'145px'"
    [offsetRight]="'16px'"
    tooltip="Relancer le contrôle"
    [tooltipPosition]="'left'"
    (fabClick)="findParadoxes()">
  </app-floating-action-button>

  <!-- Bouton Filtrer les paradoxes -->
  <app-floating-action-button
    *ngIf="hasSearched && !isSearching"
    icon="funnel-outline"
    [position]="'top-right'"
    [offsetTop]="'190px'"
    [offsetRight]="'16px'"
    tooltip="Filtrer les types de paradoxes"
    [tooltipPosition]="'left'"
    (fabClick)="openFilterPanel()">
  </app-floating-action-button>

  <!-- ===== PANNEAU DE FILTRAGE ===== -->
  <app-floating-panel
    [isOpen]="isFilterPanelOpen"
    (isOpenChange)="isFilterPanelOpen = $event"
    title="Type de contrôle"
    [position]="'right'"
    [width]="'350px'"
    (closed)="onFilterPanelClosed()">

    <div class="filter-panel-content">
      <p class="filter-description">Sélectionnez le type de paradoxe à afficher :</p>

      <ion-list class="filter-options-list">
        <ion-item 
          *ngFor="let type of paradoxTypes"
          (click)="selectParadoxType(type.id)"
          [class.selected]="selectedParadoxType === type.id"
          class="filter-option-item"
          button
          lines="none">
          <ion-icon 
            slot="start" 
            [name]="getParadoxTypeIcon(type.id)"
            [color]="selectedParadoxType === type.id ? 'primary' : 'medium'">
          </ion-icon>
          <ion-label>
            <h3>{{ type.name }}</h3>
          </ion-label>
          <ion-icon 
            *ngIf="selectedParadoxType === type.id" 
            slot="end" 
            name="checkmark-circle" 
            color="primary">
          </ion-icon>
        </ion-item>
      </ion-list>

      <ion-button 
        expand="block" 
        class="apply-filter-btn"
        (click)="applyFilterAndClose()">
        <ion-icon name="checkmark-outline" slot="start"></ion-icon>
        Appliquer et relancer
      </ion-button>
    </div>
  </app-floating-panel>

  <!-- Overlay de suppression -->
  <div *ngIf="isDeletingRelation" class="deletion-overlay">
    <ion-spinner name="dots"></ion-spinner>
    <p>Suppression en cours...</p>
  </div>
</div>

<!-- Modal de prévisualisation d'impact -->
<div *ngIf="simulationResults.isActive" class="impact-preview-overlay" (click)="closeImpactPreview()">
  <div class="impact-preview-container" (click)="$event.stopPropagation()">
    <div class="impact-preview-header">
      <h2>Impact de la suppression</h2>
      <ion-icon name="close-outline" class="close-icon" (click)="closeImpactPreview()"></ion-icon>
    </div>

    <div class="impact-preview-content">
      <p class="impact-relation">
        <strong>{{ formatRelationAsText(simulationResults.removedRelation) }}</strong>
      </p>

      <div class="impact-stats">
        <div class="impact-stat-item" [ngClass]="{
          'positive': simulationResults.removedParadoxes > 0,
          'negative': simulationResults.addedParadoxes > 0,
          'neutral': simulationResults.removedParadoxes === 0 && simulationResults.addedParadoxes === 0
        }">
          <h3>Paradoxes</h3>
          <div *ngIf="simulationResults.removedParadoxes > 0" class="positive-impact">
            <ion-icon name="checkmark-circle-outline"></ion-icon>
            <span>{{ simulationResults.removedParadoxes }} paradoxe(s) résolu(s)</span>
          </div>
          <div *ngIf="simulationResults.addedParadoxes > 0" class="negative-impact">
            <ion-icon name="alert-circle-outline"></ion-icon>
            <span>{{ simulationResults.addedParadoxes }} nouveau(x) paradoxe(s)</span>
          </div>
          <div *ngIf="simulationResults.removedParadoxes === 0 && simulationResults.addedParadoxes === 0" class="neutral-impact">
            <ion-icon name="information-circle-outline"></ion-icon>
            <span>Aucun changement</span>
          </div>
        </div>

        <div class="impact-stat-item" [ngClass]="{
          'positive': simulationResults.removedCycles > 0,
          'negative': simulationResults.addedCycles > 0,
          'neutral': simulationResults.removedCycles === 0 && simulationResults.addedCycles === 0
        }">
          <h3>Cycles</h3>
          <div *ngIf="simulationResults.removedCycles > 0" class="positive-impact">
            <ion-icon name="checkmark-circle-outline"></ion-icon>
            <span>{{ simulationResults.removedCycles }} cycle(s) résolu(s)</span>
          </div>
          <div *ngIf="simulationResults.addedCycles > 0" class="negative-impact">
            <ion-icon name="alert-circle-outline"></ion-icon>
            <span>{{ simulationResults.addedCycles }} nouveau(x) cycle(s)</span>
          </div>
          <div *ngIf="simulationResults.removedCycles === 0 && simulationResults.addedCycles === 0" class="neutral-impact">
            <ion-icon name="information-circle-outline"></ion-icon>
            <span>Aucun changement</span>
          </div>
        </div>
      </div>

      <div class="impact-actions">
        <ion-button fill="outline" (click)="closeImpactPreview()">Annuler</ion-button>
        <ion-button color="danger" (click)="confirmRemovalAfterImpactPreview()">
          <ion-icon name="trash-outline" slot="start"></ion-icon>
          Confirmer la suppression
        </ion-button>
      </div>
    </div>
  </div>
</div>